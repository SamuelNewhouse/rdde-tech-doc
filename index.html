<!-- Doctype HTML5 -->
<!doctype html>
<html lang="en" dir="ltr">

<head>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="description" content="This is my submission for the 'Build a Technical Documentation Page' project on www.freecodecamp.com.">
	<meta name="author" content="Samuel Newhouse">
	<title>How To: Responsive Diagonally Distributed Elements</title>
	<link rel="stylesheet" href="styles/style.css" type="text/css">
</head>

<body>
  <div id="open-navbar"><strong>&raquo;</strong> Contents</div>
  <nav id="navbar">
    <div id="close-navbar">X</div>
    <header>
      <h1>Responsive Diagonally<br>Distributed Elements</h1>
      by <a href="https://github.com/SamuelNewhouse" target="_blank">Samuel Newhouse</a>
    </header>
    <br>
    <a class="nav-link" href="#Introduction">Introduction</a>
    <a class="nav-link" href="#The_Basic_Concept">The Basic Concept</a>
    <a class="nav-link" href="#Vertical_Positioning">Vertical Positioning</a>
    <a class="nav-link" href="#Horizontal_Spacing">Horizontal Spacing</a>
    <a class="nav-link" href="#Calculating_the_Margins">Calculating the Margins</a>
    <a class="nav-link" href="#Blocking_on_Margin">Blocking on Margin</a>
    <a class="nav-link" href="#Container_Element_Classes">Container Element Classes</a>
    <a class="nav-link" href="#General_Framework_and_Setup">General Framework and Setup</a>
    <a class="nav-link" href="#Function_addRddeBox">Function addRddeBox</a>
    <a class="nav-link" href="#Function_checkClasses">Function checkClasses</a>
    <a class="nav-link" href="#Function_distributeElements">Function distributeElements</a>
    <a class="nav-link" href="#Container_Element_Padding">Container Element Padding</a>
    <a class="nav-link" href="#rdde-down_rdde-left-basis">rdde-down rdde-left-basis</a>
    <a class="nav-link" href="#rdde-down_rdde-right-basis">rdde-down rdde-right-basis</a>
    <a class="nav-link" href="#rdde-up_rdde-left-basis">rdde-up rdde-left-basis</a>
    <a class="nav-link" href="#rdde-up_rdde-right-basis">rdde-up rdde-right-basis</a>
    <a class="nav-link" href="#Completed_JavaScript">Completed JavaScript</a>
    <a class="nav-link" href="#Compare_Blocking_Cases">Compare Blocking Cases</a>
    <a class="nav-link" href="#Compare_Non-Blocking_Cases">Compare Non-Blocking Cases</a>
    <a class="nav-link" href="#Conclusion_and_Improvements">Conclusion and Improvements</a>
    <br>
  </nav>

  <main id="main-doc">
	<section id="Introduction" class="main-section">
    <header><h2>Introduction</h2></header>
		<div class="collapse-left example">
			<div class="rdde">
				<span>Hello</span>
				<span>world.</span>
				<span>How</span>
				<span>are</span>
				<span>you?</span>
			</div>
		</div>
		<div>
			<p>This document explains how to implement responsive diagonally distributed elements (RDDE) using JavaScript. To simplify things,
        <a href="https://github.com/sdecima/javascript-detect-element-resize" target="_blank">JavaScript Detect Element Resize</a>
        by <a href="https://github.com/sdecima" target="_blank">Sebastian Decima</a>
        is used to detect resizes and make the code fully responsive. After finishing, you will have a replica of v0.1 of
        <a href="https://github.com/SamuelNewhouse/responsive-diagonally-distributed-elements" target="_blank">Responsive Diagonally Distributed Elements</a> by <a href="https://github.com/SamuelNewhouse" target="_blank">Samuel Newhouse</a>,
        created from the ground-up, with an understanding of how it works.</p>
			<p>This implementation relies on setting class names on a dedicated container element. The classes used and the size of the container element determine how its inner elements will be distributed. The class names will set the rules for:</p>
				<ol>
					<li>The angle of distribution (diagonally down or up)</li>
					<li>The basis for alignment (left or right margin)</li>
					<li>Blocking or not blocking elements from crossing the basis margin.</li>
				</ol>
			<p>More options could be added to increase sophistication, but these three offer a solid starting point for understanding some of the complicating factors to consider when trying to create RDDE.</p>
		</div>
	</section>

	<section id="The_Basic_Concept" class="main-section">
		<header><h2>The Basic Concept</h2></header>
		<p>The most basic situation to consider is aligning a set of elements on a downhill diagonal starting from the left margin.</p>
		<img src="images/basic-plan.png">
		<p>The inner element centers are spaced equidistant horizontally and the center of each element is on the distribution diagonal. The distribution diagonal is more of a conceptual aid than something fully calculated. Only the horizontal starting and ending point of the diagonal, relative to the left margin, are needed to begin with. These are determined by setting the starting horizontal position to the horizontal center of the first element and the ending horizontal position to the horizontal center of the last element. This will create a smoother and more consistent diagonal alignment that simply going from corner to corner of the container element.</p>
		<p>There is no need to worry about the height of the container element or the heights of the inner elements. Flexbox is used to distribute the elements vertically by using flex-direction: column and justify-content: space-between. This effectively automates the slope of the diagonal without having to do any additional JavaScript operations. However, it's important to note that having inner elements with varying heights will throw off the diagonal alignment. Leveraging flexbox to reduce JavaScript usage requires each element to be on it's own line due to <strong>flex-direction:column</strong>.</p>
	</section>

	<section id="Vertical_Positioning" class="main-section">
		<header><h2>Vertical Positioning</h2></header>
		<p>Keep in mind that ALL vertical positioning is determined entirely by using flexbox. The vertical start and end of the distribution diagonal, as well as each inner element's vertical position, are all automatically handled by using a flexbox set to <strong>flex-direction: column</strong> and <strong>justify-content: space-between</strong>. The only thing that will need to be implemented in JavaScript is the horizontal positioning.</p>
	</section>

	<section id="Horizontal_Spacing" class="main-section">
		<header><h2>Horizontal Spacing</h2></header>
		<p>It's easy to say that each element's center should align on the distribution diagonal, but how is that done? One idea is to set a separate left margin for each inner element in a way that makes all the inner elements line up diagonally. This requires a separate calculation for each inner element based on several factors...</p>
		<ol>
			<li>Width of outer container element</li>
			<li>Horizontal size of the distribution diagonal (distance between first and last element centers)</li>
			<li>Number of inner elements</li>
			<li>Width of the individual element being aligned</li>
		</ol>
		<p>Here is a diagram with the first three of those considerations put into relationship with each other.</p>
		<img src="images/horizontal-positioning.png">
		<ol>
			<li><strong>box.clientWidth</strong> = Width of outer container element</li>
			<li><strong>innerWidth</strong> = Horizontal size of the distribution diagonal</li>
			<li><strong>numParts</strong> = Number of inner elements</li>
		</ol>
		<p><strong>box.clientWidth</strong> is necessary for calculating <strong>innerWidth</strong>. Despite the diagram's appearance, the inner elements are not automatically spaced apart so that the last element's center falls in its proper place. Instead, we have to calculate <strong>innerStart</strong>, <strong>innerEnd</strong> and <strong>innerWidth</strong> by doing the following...</p>
<pre><code>// parts is an array of all the inner elements.
innerStart = parts[0].clientWidth / 2;
innerEnd = box.clientWidth - (parts[numParts - 1].clientWidth / 2);
innerWidth = innerEnd - innerStart;</code></pre>
		<p>With <strong>innerWidth</strong> and <strong>numParts</strong> known, it's possible to calculate the horizontal spacing between element centers. This is the <strong>splitWidth</strong> and can be calculated by dividing <strong>innerWidth</strong> by one less than <strong>numParts</strong>.</p>
<pre><code>splitWidth = innerWidth / (numParts - 1);</code></pre>
	</section>

	<section id="Calculating_the_Margins" class="main-section">
		<header><h2>Calculating the Margins</h2></header>
		<p>Now look at how to use <strong>splitWidth</strong> with individual element widths to set the left margins...</p>
		<img src="images/horizontal-positioning2.png">
		<p>There are several things added here that need explanation...</p>
		<p><strong>firstOffset:</strong> It's exactly the same value as <strong>innerStart</strong>. That may seem pointless, but it's to make explicit a meaningful contrast between itself and <strong>lastOffset</strong>.</p>
		<p><strong>lastOffset:</strong> NOT the same value as <strong>innerEnd</strong>. <strong>innerEnd</strong> is the distance from the left margin to where the horizontal center of the last element will be. <strong>lastOffset</strong> is half the width of the last element while <strong>firstOffset</strong> is half the width of the first element. This becomes more important in future examples.</p>
		<p><strong>align-items="flex-start":</strong> This is critical. Since the outer container is a flex box, the default alignment is "stretch". Using that default alignment would prevent properly using left margins as a method for aligning items diagonally. By setting the alignment to flex-start, all the inner elements will line up on the left side of the outer container. Then, the left margin of every element can be set to push them away from the left side as needed.</p>
		<p>Now on to the <strong>marginLeft</strong> calculations...</p>
		<p><strong>splitWidth * i:</strong> One <strong>splitWidth</strong> worth of distance needs to be added for each inner element, so multiplying by an index counter works well here.</p>
		<p><strong>+ firstOffset:</strong> Adding <strong>firstOffset</strong> pushes each use of <strong>splitWidth</strong> over so the <strong>splitWidth</strong> distribution starts where it's supposed to (center of the first element).</p>
		<p><strong>- parts[i].clientWidth / 2:</strong> This is where each individual element width is taken into account. Even if the elements are different widths, this maintains every element's center position on the distribution diagonal.</p>
		<p>In summary, the equivalent JavaScript so far would be...</p>
<pre><code>// box is the container element for the parts
box.style.display = &#x22;flex&#x22;;
box.style.flexDirection = &#x22;column&#x22;;
box.style.justifyContent = &#x22;space-between&#x22;;
box.style.alignItems = &#x22;flex-start&#x22;;

var parts = box.children;
var numParts = parts.length

var firstOffset = parts[0].clientWidth / 2;
var lastOffset = parts[numParts - 1].clientWidth / 2;

var innerStart = firstOffset;
var innerEnd = box.clientWidth - lastOffset;

var innerWidth = innerEnd - innerStart;
var splitWidth = innerWidth / (numParts - 1);

// It&#x27;s safe to skip i=0
for (let i = 1; i &lt; numParts; i++) {
  let marginLeft = splitWidth * i + firstOffset - parts[i].clientWidth / 2;
  parts[i].style.marginLeft = marginLeft + &#x22;px&#x22;;
}</code></pre>
	<p>Notice the loop starts at <strong>i = 1</strong>. It's unnecessary to calculate <strong>i = 0</strong> because it will always result in a zero left margin. Setting a zero left margin is the same as not setting a left margin since <strong>align-items: flex-start</strong> is being used.</p>
	</section>

	<section id="Blocking_on_Margin" class="main-section">
		<header><h2>Blocking on Margin</h2></header>
		<div class="rdde rdde-no-block example block-compare">
			<span>Test</span>
			<span>for</span>
			<span>margin</span>
			<span>blocking</span>
			<span>here.</span>
		</div>
		<p>One possible issue with this method is that elements can receive negative margins if the container element becomes small enough. This is especially a problem if some elements are much larger than others. It many cases, it would probably be better to have elements stop at zero left margin rather than go past that into the negatives. Luckily, this is fixed with a simple addition to the for loop...</p>
<pre><code>for (let i = 1; i &lt; numParts; i++) {
  let marginLeft = splitWidth * i + firstOffset - parts[i].clientWidth / 2;
  marginLeft = Math.max(0, marginLeft);
  parts[i].style.marginLeft = marginLeft + &#x22;px&#x22;;
}</code></pre>
	<div class="rdde example block-compare">
		<span>Test</span>
		<span>for</span>
		<span>margin</span>
		<span>blocking</span>
		<span>here.</span>
	</div>
	<p>That solves the problem, but it might be good to include an option for turning this blocking off. Checking for the existence of a particular class on the container element would do the trick.</p>
<pre><code>var bBlock = !box.classList.contains(&#x22;rdde-no-block&#x22;);

for (let i = 1; i &#x3C; numParts; i++) {
  let marginLeft = splitWidth * i + firstOffset - parts[i].clientWidth / 2;
  if (bBlock)
    marginLeft = Math.max(0, marginLeft);
  parts[i].style.marginLeft = marginLeft + &#x22;px&#x22;;
}</code></pre>
	<p>Since the default case will be to block on the margin, the optional case must be to explicitly not block.</p>
	</section>

	<section id="Container_Element_Classes" class="main-section">
		<header><h2>Container Element Classes</h2></header>
		<p>The previous section introduced the class "rdde-no-block". As mentioned at the very beginning, RDDE uses classes on elements to determine what elements are RDDE elements and what the settings will be.</p>
<pre><code>&lt;div class=&quot;rdde&quot;&gt;
  &lt;span&gt;A&lt;/span&gt;
  &lt;span&gt;B&lt;/span&gt;
  &lt;span&gt;C&lt;/span&gt;
&lt;/div&gt;</code></pre>
		<p>The above code demonstrates the idea. Simplying giving the outter div the <strong>rdde</strong> class will allow it to diagonally distribute the three inside spans. Here are the classes covered in this document...</p>
		<table>
			<tr><td><strong>rdde</strong> <em>(required)</em>:</td> <td>sets up an element as the container</td></tr>
			<tr><td><strong>rdde-down</strong> <em>(default)</em>:</td> <td>align inner elements diagonally down</td></tr>
			<tr><td><strong>rdde-up</strong>:</td> <td>align inner elements diagonally up</td></tr>
			<tr><td><strong>rdde-left-basis</strong> <em>(default)</em>:</td> <td>calculate inner elements from left and block on left margin</td></tr>
			<tr><td><strong>rdde-right-basis</strong>:</td> <td>calculate inner elements from right and block on right margin</td></tr>
			<tr><td><strong>rdde-no-block</strong>:</td> <td>turn off blocking so elements can cross basis margin</td></tr>
		</table>
		<p><strong>rdde-down</strong> with <strong>rdde-left-basis</strong> is essentially the concept and code that has been covered so far, along with <strong>rdde-no-block</strong>. With these as a starting point, now might be a good time to implement the more general foundations for the code. Once that is done, the other options are fairly easy to add later.</p>
	</section>

	<section id="General_Framework_and_Setup" class="main-section">
		<header><h2>General Framework and Setup</h2></header>
		<p>Now that the general concepts and goals have been established, it's time to start creating RDDE as its own JavaScript file to be included in HTML (this file will be <strong>responsive-diagonally-distributed-elements.js</strong>). <strong>javascript-detect-element-resize.js</strong> needs to load before <strong>responsive-diagonally-distributed-elements.js</strong>. In this document, they are simply included in order right before the closing tag for the body...</p>
<pre><code>&lt;/footer&gt;

  &lt;script src=&quot;scripts/javascript-detect-element-resize.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;scripts/responsive-diagonally-distributed-elements.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;</code></pre>
 <p>Additionally, the RDDE code needs to wait for the DOM content to be loaded before doing anything. To ensure all of this is done correctly, the following code waits for DOM content to finish loading, checks for the existence of javascript-detect-element-resize.js, and provides an error message and a suggested link if something is wrong.</p>
<pre><code>document.addEventListener(&quot;DOMContentLoaded&quot;, function () {
  if (typeof window.addResizeListener !== &quot;function&quot; || typeof window.removeResizeListener !== &quot;function&quot;) {
    console.log(&quot;ERROR: javascript-detect-element-resize.js is required for diagonally-distributed-elements.js&quot;);
    console.log(&quot;See: https://github.com/sdecima/javascript-detect-element-resize&quot;);
    return;
  }
});</code></pre>

		<p>javascript-detect-element-resize.js adds the functions <strong>addResizeListener</strong> and <strong>removeResizeListener</strong> to the window object. If those functions don't exist on the window object, it's safe to assume javascript-detect-element-resize.js isn't loaded. After that consideration, it's time to see if any elements actually have the <strong>rdde</strong> class assigned to them...</p>
<pre><code>document.addEventListener(&#x22;DOMContentLoaded&#x22;, function () {
  if (typeof window.addResizeListener !== &#x22;function&#x22; || typeof window.removeResizeListener !== &#x22;function&#x22;) {
    console.log(&#x22;ERROR: javascript-detect-element-resize.js is required for diagonally-distributed-elements.js&#x22;);
    console.log(&#x22;See: https://github.com/sdecima/javascript-detect-element-resize&#x22;);
    return;
  }

  var boxes = document.getElementsByClassName(&#x22;rdde&#x22;);
  if (boxes.length == 0) {
    console.log(&#x22;Note: No elements with rdde class.&#x22;);
    return;
  }

  for (let i = 0; i &#x3C; boxes.length; i++)
    addRddeBox(boxes[i]);

  function addRddeBox(box) {
  }

  function checkClasses(box) {
  }

  function distributeElements() {
  }
});</code></pre>

	<p>If there are no elements with the <strong>rdde</strong> class, log a note saying so and return. If there are any elements with the <strong>rdde</strong> class, then <strong>addRddeBox</strong> gets passed each of those elements individually to start setting them up. Each function will be covered separately in further sections, but here is a quick breakdown.</p>
	<p><strong>addRddeBox:</strong> Sets the general style that will apply to every RDDE element, calls <strong>checkClasses</strong>, and sets the callback necessary to make everything responsive.</p>
	<p><strong>checkClasses:</strong> Checks for class options and sets defaults if not already set; also sets class specific flexbox properties.</p>
	<p><strong>distributeElements:</strong> The function that actually performs element distribution. It's also the callback function passed to <strong>window.addResizeListener</strong>.</p>
	</section>

	<section id="Function_addRddeBox" class="main-section">
		<header><h2>Function addRddeBox</h2></header>
<pre><code>function addRddeBox(box) {
  box.style.display = &#x22;flex&#x22;;
  box.style.flexDirection = &#x22;column&#x22;;
  box.style.justifyContent = &#x22;space-between&#x22;;
  // If text wraps, this keeps it looking good
  box.style.textAlign = &#x22;center&#x22;; // &#x3C;--------

  checkClasses(box);
  window.addResizeListener(box, distributeElements);
}</code></pre>
	<p>The styles set here apply to every RDDE element regardless of other options. <strong>textAlign = "center"</strong> is a good method for maintaining an even looking distribution if text in an inner element wraps. When text wraps, the element's <strong>clientWidth</strong> won't necessarily match the apparent text width. Centering the text within its container element makes this be much less of a problem.</p>
	<p><strong>checkClasses</strong> will be covered in the next section.</p>
	<p><strong>window.addResizeListener</strong> is a function created by <strong>javascript-detect-element-resize.js</strong>. The first argument accepts an element (box) that it monitors for resize. The second argument is a function that it will call anytime it detects that box has been resized. When <strong>addResizeListener</strong> calls <strong>distributeElements</strong>, it will set its this value to the element being resized. </p>
	</section>

	<section id="Function_checkClasses" class="main-section">
		<header><h2>Function checkClasses</h2></header>
<pre><code>function checkClasses(box) {
  var classes = box.classList;

  // Set defaults if not set.
  if (!classes.contains(&#x22;rdde-left-basis&#x22;) &#x26;&#x26; !classes.contains(&#x22;rdde-right-basis&#x22;))
    box.classList.add(&#x22;rdde-left-basis&#x22;);
  if (!classes.contains(&#x22;rdde-down&#x22;) &#x26;&#x26; !classes.contains(&#x22;rdde-up&#x22;))
    box.classList.add(&#x22;rdde-down&#x22;);

  if (classes.contains(&#x22;rdde-left-basis&#x22;))
    box.style.alignItems = &#x22;flex-start&#x22;;
  else
    box.style.alignItems = &#x22;flex-end&#x22;;
}</code></pre>
	<p>Any default settings not overridden or made explicit will be added. This also sets the proper flexbox <strong>alignItems</strong> for <strong>rdde-left-basis</strong> and <strong>rdde-right-basis</strong>. <strong>rdde-down</strong> and <strong>rdde-right-basis</strong> will be fully explained later. They can be safely placed in the code now without interfering with the default options.</p>
	</section>

	<section id="Function_distributeElements" class="main-section">
		<header><h2>Function distributeElements</h2></header>
		<p>At this point, only the code for the left basis down sloping diagonal will be included here. Later, the code for all the other option combinations will be explained.</p>
<pre><code>function distributeElements() {
  var box = this;
  var parts = box.children;
  // Last child will be a div added from javascript-detect-element-resize.js.
  // It must be ignored for this to work properly.
  var numParts = parts.length - 1; // &#x3C;-----------

  var firstOffset = parts[0].clientWidth / 2;
  var lastOffset = parts[numParts - 1].clientWidth / 2;

  var innerStart = firstOffset;
  var innerEnd = box.clientWidth - lastOffset;

  var innerWidth = innerEnd - innerStart;
  var splitWidth = innerWidth / (numParts - 1);

  var bBlock = !box.classList.contains(&#x22;rdde-no-block&#x22;);

  if (box.classList.contains(&#x22;rdde-down&#x22;)) {
    if (box.classList.contains(&#x22;rdde-left-basis&#x22;)) {
      for (let i = 1; i &#x3C; numParts; i++) {
        let marginLeft = splitWidth * i + firstOffset - parts[i].clientWidth / 2;
        if (bBlock)
          marginLeft = Math.max(0, marginLeft);
        parts[i].style.marginLeft = marginLeft + &#x22;px&#x22;;
      }
    }
    else {  // &#x3C;-- box.classList.contains(&#x22;rdde-right-basis&#x22;)
    }
  }
  else {    // &#x3C;-- box.classList.contains(&#x22;rdde-up&#x22;)
    if (box.classList.contains(&#x22;rdde-left-basis&#x22;)) {
    }
    else {  // &#x3C;-- box.classList.contains(&#x22;rdde-right-basis&#x22;)
    }
  }
}</code></pre>
	<p>Most of these lines of code have been covered before, but there are a few new twists...</p>
<pre><code>var box = this;</code></pre>
	<p><strong>this</strong> is set to the element being resized when <strong>distributeElements</strong> is called from javascript-detect-element-resize.js.</p>
<pre><code>var numParts = parts.length - 1;</code></pre>
	<p>javascript-detect-element-resize.js adds a div to the end of the container element. It must be ignored.</p>
	<p>The <strong>if</strong> statements are a bit messy. But essentially, there are four combinations of settings, each requiring a different method for calculating the margins.</p>
	<p>This code is now ready to work for the default configuration, if there is no padding on the container element. The next section will show how to modify the code to allow for padding.</p>
	</section>

	<section id="Container_Element_Padding" class="main-section">
		<header><h2>Container Element Padding</h2></header>
		<p>Since it's fairly easy to account for an RDDE element itself having padding, that consideration will be added to the code by modifying <strong>distributeElements</strong>...</p>
<pre><code>function distributeElements() {
  var box = this;
  var parts = box.children;
  // Last child will be a div added from javascript-detect-element-resize.js.
  // It must be ignored for this to work properly.
  var numParts = parts.length - 1; // &#x3C;-----------

  var boxCS = getComputedStyle(box);
  var distributionWidth =   // Distribution should occur inside of any padding...
      box.clientWidth - parseFloat(boxCS.paddingLeft) - parseFloat(boxCS.paddingRight);

  var firstOffset = parts[0].clientWidth / 2;
  var lastOffset = parts[numParts - 1].clientWidth / 2;

  var innerStart = firstOffset;
  var innerEnd = distributionWidth - lastOffset;

  var innerWidth = innerEnd - innerStart;
  var splitWidth = innerWidth / (numParts - 1);
  ...
</code></pre>
		<p>It's a fairly simple change. The computed style of the RDDE box is placed in the variable <strong>boxCS</strong>. Then new variable called <strong>distributionWidth</strong> is added to store the width between left and right padding. <strong>distributionWidth</strong> is then used to calculate an <strong>innerEnd</strong> suitable for the padding. Although the code for assigning <strong>splitWidth</strong> is unchanged, it's influenced by <strong>innerWidth</strong> which is influenced by <strong>innerEnd</strong>, meaning the change propogates correctly through the code.</p>
		<p>From this point forward, keep in mind that this change properly handles padding. To avoid clutter, it's not explicitly shown in any diagrams, but imagining any padding to exist outside the diagrams is conceptually accurate.</p>
	</section>

	<section id="rdde-down_rdde-left-basis" class="main-section">
		<header><h2>rdde-down rdde-left-basis</h2></header>
		<p>This is what has already been covered as the basic starting point. It's the default to be used if no direction or basis is provided.</p>
		<img src="images/down_left-basis.png">
		<p>There's is nothing to add here in terms of code or explanation. It's here more for convenience so all four options are laid out in sequence for comparison.</p>
	</section>

	<section id="rdde-down_rdde-right-basis" class="main-section">
		<header><h2>rdde-down rdde-right-basis</h2></header>
		<p></p>
		<img src="images/down_right-basis.png">
		<p>The first thing to notice here is that <strong>align-items</strong> is set to <strong>flex-end</strong>. This allows the right margin to be used for distributing the inner elements. There is also a new variable called <strong>iMirror</strong>. This gets the mirror index of the current index for the parts array so <strong>splitWidth</strong> can be multiplied by the proper amount. <strong>lastOffset</strong> is also being used in this situation instead of <strong>firstOffset</strong>. Starting from the right margin requires this.</p>
		<p>Incorporating this into the existing JavaScript code is done in the main if statement in <strong>distributeElements</strong> function...</p>
<pre><code>if (box.classList.contains(&quot;rdde-down&quot;)) {
  if (box.classList.contains(&quot;rdde-left-basis&quot;)) {
    for (let i = 1; i &lt; numParts; i++) {
      let marginLeft = splitWidth * i + firstOffset - parts[i].clientWidth / 2;
      if (bBlock)
        marginLeft = Math.max(0, marginLeft);
        parts[i].style.marginLeft = marginLeft + &quot;px&quot;;
      }
    }
    else { // box.classList.contains(&quot;rdde-right-basis&quot;)
      for (let i = 0; i &lt; numParts - 1; i++) {
        let iMirror = numParts - i - 1;
        let marginRight = splitWidth * iMirror + lastOffset - parts[i].clientWidth / 2;
        if (bBlock)
          marginRight = Math.max(0, marginRight);
        parts[i].style.marginRight = marginRight + &quot;px&quot;;
    }
  }
}
else { // box.classList.contains(&quot;rdde-up&quot;)
    if (box.classList.contains(&quot;rdde-left-basis&quot;)) {
    }
    else { // box.classList.contains(&quot;rdde-right-basis&quot;)
    }
}</code></pre>
		<p>There's another mirror (of a kind) here in addition to <strong>iMirror</strong>. The index counter for <strong>rdde-left-basis</strong> + <strong>rdde-down</strong> starts at 1 because the 0 index can be ignored. Similarly, the last index can be ignored in the case of <strong>rdde-right-basis</strong> + <strong>rdde-down</strong>. The last index is going always going to set far right, so there's no need to calculate the <strong>rightMargin</strong> for it.</p>
	</section>

	<section id="rdde-up_rdde-left-basis" class="main-section">
		<header><h2>rdde-up rdde-left-basis</h2></header>
		<img src="images/up_left-basis.png">
		<p>In this diagram, the first element (<strong>i=0</strong>) is on the right instead of the left. This points to an important philosophical choice to be made for uphill diagonals. It might be argued that the order of elements should be automatically reversed in the RDDE code since a long uphill diagonal will be naturally read from left to right. That means not reversing the order could lead to confusion in some cases as the bottom element will probably be looked at first instead of the top element.</p>
		<p>However, automatically reversing the order could also lead to confusion. As the diagonal shrinks and gets closer to vertical alignment, the more natural it becomes to read from top to bottom instead of left to right. This leaves the natural reading order ambiguous in many cases, and completely unknown from the perspective of trying to develop for all possible scenarios. The decision for RDDE is to leave the vertical order intact as it sits in the HTML. It's up to the developer to place the elements in the order they see fit.</p>
		<p>For the code, just keep filling out the <strong>if-else</strong> statements to match the diagrams...</p>
<pre><code>if (box.classList.contains(&quot;rdde-down&quot;)) {
  if (box.classList.contains(&quot;rdde-left-basis&quot;)) {
    for (let i = 1; i &lt; numParts; i++) {
      let marginLeft = splitWidth * i + firstOffset - parts[i].clientWidth / 2;
      if (bBlock)
        marginLeft = Math.max(0, marginLeft);
      parts[i].style.marginLeft = marginLeft + &quot;px&quot;;
    }
  }
  else { // box.classList.contains(&quot;rdde-right-basis&quot;)
    for (let i = 0; i &lt; numParts - 1; i++) {
      let iMirror = numParts - i - 1;
      let marginRight = splitWidth * iMirror + lastOffset - parts[i].clientWidth / 2;
      if (bBlock)
        marginRight = Math.max(0, marginRight);
      parts[i].style.marginRight = marginRight + &quot;px&quot;;
    }
  }
}
else { // box.classList.contains(&quot;rdde-up&quot;)
  if (box.classList.contains(&quot;rdde-left-basis&quot;)) {
    for (let i = 0; i &lt; numParts - 1; i++) {
      let iMirror = numParts - i - 1;
      let marginLeft = splitWidth * iMirror + lastOffset - parts[i].clientWidth / 2;
      if (bBlock)
        marginLeft = Math.max(0, marginLeft);
      parts[i].style.marginLeft = marginLeft + &quot;px&quot;;
    }
  }
  else { // box.classList.contains(&quot;rdde-right-basis&quot;)
  }
}</code></pre>
		<p>There's not much to point out about this code other than it's identical to the last section except <strong>marginLeft</strong> is being set instead of <strong>marginRight</strong>.</p>
	</section>

	<section id="rdde-up_rdde-right-basis" class="main-section">
		<header><h2>rdde-up rdde-right-basis</h2></header>
		<img src="images/up_right-basis.png">
		<p>This is just like the default option except everything is set away from the right margin instead of the left margin.</p>
<pre><code>var bBlock = !box.classList.contains(&#x22;rdde-no-block&#x22;);
if (box.classList.contains(&#x22;rdde-down&#x22;)) {
  if (box.classList.contains(&#x22;rdde-left-basis&#x22;)) {
    for (let i = 1; i &#x3C; numParts; i++) {
      let marginLeft = splitWidth * i + firstOffset - parts[i].clientWidth / 2;
      if (bBlock)
        marginLeft = Math.max(0, marginLeft);
      parts[i].style.marginLeft = marginLeft + &#x22;px&#x22;;
    }
  }
  else { // box.classList.contains(&#x22;rdde-right-basis&#x22;)
    for (let i = 0; i &#x3C; numParts - 1; i++) {
      let iMirror = numParts - i - 1;
      let marginRight = splitWidth * iMirror + lastOffset - parts[i].clientWidth / 2;
      if (bBlock)
        marginRight = Math.max(0, marginRight);
      parts[i].style.marginRight = marginRight + &#x22;px&#x22;;
    }
  }
}
else { // box.classList.contains(&#x22;rdde-up&#x22;)
  if (box.classList.contains(&#x22;rdde-left-basis&#x22;)) {
    for (let i = 0; i &#x3C; numParts - 1; i++) {
      let iMirror = numParts - i - 1;
      let marginLeft = splitWidth * iMirror + lastOffset - parts[i].clientWidth / 2;
      if (bBlock)
        marginLeft = Math.max(0, marginLeft);
      parts[i].style.marginLeft = marginLeft + &#x22;px&#x22;;
    }
  }
  else { // box.classList.contains(&#x22;rdde-right-basis&#x22;)
    for (let i = 1; i &#x3C; numParts; i++) {
      let marginRight = splitWidth * i + firstOffset - parts[i].clientWidth / 2;
      if (bBlock)
        marginRight = Math.max(0, marginRight);
      parts[i].style.marginRight = marginRight + &#x22;px&#x22;;
    }
  }
}</code></pre>
	</section>

	<section id="Completed_JavaScript" class="main-section">
    <header><h2>Completed JavaScript</h2></header>
    <p>At this point, all the code for v0.1 of <strong>responsive-diagonally-distributed-elements.js</strong> should be complete and look like this...</p>
<pre><code>document.addEventListener(&#x22;DOMContentLoaded&#x22;, function () {
  if (typeof window.addResizeListener !== &#x22;function&#x22; || typeof window.removeResizeListener !== &#x22;function&#x22;) {
    console.log(&#x22;ERROR: javascript-detect-element-resize.js is required for diagonally-distributed-elements.js&#x22;);
    console.log(&#x22;See: https://github.com/sdecima/javascript-detect-element-resize&#x22;);
    return;
  }

  var boxes = document.getElementsByClassName(&#x22;rdde&#x22;);
  if (boxes.length == 0) {
    console.log(&#x22;Note: No elements with rdde class.&#x22;);
    return;
  }

  for (let i = 0; i &#x3C; boxes.length; i++)
    addRddeBox(boxes[i]);

  function addRddeBox(box) {
    box.style.display = &#x22;flex&#x22;;
    box.style.flexDirection = &#x22;column&#x22;;
    box.style.justifyContent = &#x22;space-between&#x22;;
    // If text wraps, this keeps the diagonal alignment looking good
    box.style.textAlign = &#x22;center&#x22;; // &#x3C;----------------------------

    checkClasses(box);
    window.addResizeListener(box, distributeElements);
  }

  function checkClasses(box) {
    var classes = box.classList;

    // Set defaults if not set.
    if (!classes.contains(&#x22;rdde-left-basis&#x22;) &#x26;&#x26; !classes.contains(&#x22;rdde-right-basis&#x22;))
      box.classList.add(&#x22;rdde-left-basis&#x22;);
    if (!classes.contains(&#x22;rdde-down&#x22;) &#x26;&#x26; !classes.contains(&#x22;rdde-up&#x22;))
      box.classList.add(&#x22;rdde-down&#x22;);

    if (classes.contains(&#x22;rdde-left-basis&#x22;))
      box.style.alignItems = &#x22;flex-start&#x22;;
    else
      box.style.alignItems = &#x22;flex-end&#x22;;
  }

  function distributeElements() {
    var box = this;
    var parts = box.children;
    // Last child will be a div added from javascript-detect-element-resize.js.
    // It must be ignored for this to work properly.
    var numParts = parts.length - 1; // &#x3C;-----------

    var boxCS = getComputedStyle(box);
    var distributionWidth =    // Distribution must occur inside of any padding...
      box.clientWidth - parseFloat(boxCS.paddingLeft) - parseFloat(boxCS.paddingRight);

    var firstOffset = parts[0].clientWidth / 2;
    var lastOffset = parts[numParts - 1].clientWidth / 2;

    var innerStart = firstOffset;
    var innerEnd = distributionWidth - lastOffset;

    var innerWidth = innerEnd - innerStart;
    var splitWidth = innerWidth / (numParts - 1);

    var bBlock = !box.classList.contains(&#x22;rdde-no-block&#x22;);
    if (box.classList.contains(&#x22;rdde-down&#x22;)) {
      if (box.classList.contains(&#x22;rdde-left-basis&#x22;)) {
        for (let i = 1; i &#x3C; numParts; i++) {
          let marginLeft = splitWidth * i + firstOffset - parts[i].clientWidth / 2;
          if (bBlock)
            marginLeft = Math.max(0, marginLeft);
          parts[i].style.marginLeft = marginLeft + &#x22;px&#x22;;
        }
      }
      else { // box.classList.contains(&#x22;rdde-right-basis&#x22;)
        for (let i = 0; i &#x3C; numParts - 1; i++) {
          let iMirror = numParts - i - 1;
          let marginRight = splitWidth * iMirror + lastOffset - parts[i].clientWidth / 2;
          if (bBlock)
            marginRight = Math.max(0, marginRight);
          parts[i].style.marginRight = marginRight + &#x22;px&#x22;;
        }
      }
    }
    else { // box.classList.contains(&#x22;rdde-up&#x22;)
      if (box.classList.contains(&#x22;rdde-left-basis&#x22;)) {
        for (let i = 0; i &#x3C; numParts - 1; i++) {
          let iMirror = numParts - i - 1;
          let marginLeft = splitWidth * iMirror + lastOffset - parts[i].clientWidth / 2;
          if (bBlock)
            marginLeft = Math.max(0, marginLeft);
          parts[i].style.marginLeft = marginLeft + &#x22;px&#x22;;
        }
      }
      else { // box.classList.contains(&#x22;rdde-right-basis&#x22;)
        for (let i = 1; i &#x3C; numParts; i++) {
          let marginRight = splitWidth * i + firstOffset - parts[i].clientWidth / 2;
          if (bBlock)
            marginRight = Math.max(0, marginRight);
          parts[i].style.marginRight = marginRight + &#x22;px&#x22;;
        }
      }
    }
  }
});</code></pre>
  </section>

	<section id="Compare_Blocking_Cases" class="main-section">
    <header><h2>Compare Blocking Cases</h2></header>
    <p>In this section, click anywhere in the container elements to shrink or expand each box. Notice how <strong>rdde-left-basis</strong> and <strong>rdde-right-basis</strong> differ. Padding is also used in these <strong>rdde</strong> containers to demonstrate it working.</p>
    <h3>rdde-down rdde-left-basis</h3>
		<div class="rdde example blocking-cases size-toggle">
			<span>A</span>
			<span>great</span>
			<span>glorious</span>
			<span>test.</span>
		</div>
    <h3>rdde-down rdde-right-basis</h3>
		<div class="rdde rdde-right-basis example blocking-cases size-toggle">
			<span>A</span>
			<span>great</span>
		  <span>glorious</span>
			<span>test.</span>
    </div>
    <h3>rdde-up rdde-left-basis</h3>
		<div class="rdde rdde-up example blocking-cases size-toggle">
			<span>A</span>
			<span>great</span>
			<span>glorious</span>
			<span>test.</span>
    </div>
    <h3>rdde-up rdde-right-basis</h3>
		<div class="rdde rdde-up rdde-right-basis example blocking-cases size-toggle">
			<span>A</span>
			<span>great</span>
			<span>glorious</span>
			<span>test.</span>
    </div>
    <br>
  </section>

  <section id="Compare_Non-Blocking_Cases" class="main-section">
    <header><h2>Compare Non-Blocking Cases</h2></header>
    <p>When margin blocking is turned off using <strong>rdde-no-block</strong>, the basis margin becomes essentially irrelevant. Click inside each container element to see what happens.</p>
    <h3>rdde-down rdde-left-basis rdde-no-block</h3>
		<div class="rdde rdde-no-block example blocking-cases size-toggle">
			<span>A</span>
			<span>great</span>
			<span>glorious</span>
			<span>test.</span>
		</div>
    <h3>rdde-down rdde-right-basis rdde-no-block</h3>
		<div class="rdde rdde-right-basis rdde-no-block example blocking-cases size-toggle">
			<span>A</span>
			<span>great</span>
		  <span>glorious</span>
			<span>test.</span>
    </div>
    <h3>rdde-up rdde-left-basis rdde-no-block</h3>
		<div class="rdde rdde-up rdde-no-block example blocking-cases size-toggle">
			<span>A</span>
			<span>great</span>
			<span>glorious</span>
			<span>test.</span>
    </div>
    <h3>rdde-up rdde-right-basis rdde-no-block</h3>
		<div class="rdde rdde-up rdde-right-basis rdde-no-block example blocking-cases size-toggle">
			<span>A</span>
			<span>great</span>
			<span>glorious</span>
			<span>test.</span>
    </div>
    <br>
  </section>

	<section id="Conclusion_and_Improvements" class="main-section">
    <header><h2>Conclusion and Improvements</h2></header>
    <p>There are several ways to improve both the performance and capabilities of RDDE v0.1. For performance, <strong>rdde</strong> container element data could be stored to reduce DOM lookups. For capabilities, an option could be added to set all inner elements to the same height to ensure perfect diagonal alignment in the case of varying heights. At the time of writing this document, v0.1 is the only version. Visit the <a href="https://github.com/SamuelNewhouse/responsive-diagonally-distributed-elements" target="_blank">RDDE github page</a> to check for newer versions or make contributions to the code.</p>
   </section>

	<footer><br>
    Made by
		<a href="https://github.com/SamuelNewhouse" target="_blank">Samuel Newhouse</a>
	</footer>
  </main>

	<script src="scripts/javascript-detect-element-resize.js"></script>
  <script src="scripts/responsive-diagonally-distributed-elements.js"></script>
  <script src="scripts/script.js"></script>
  <script src="scripts/bundle.js"></script>
</body>

</html>